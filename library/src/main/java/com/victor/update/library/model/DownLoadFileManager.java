package com.victor.update.library.model;import android.util.Log;import com.victor.update.library.data.UpdateData;import com.victor.update.library.interfaces.OnDownloadProgressListener;import java.io.BufferedInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLConnection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by victor on 2017/3/3. */public class DownLoadFileManager {    private String TAG = "DownLoadFileManager";    private static final int TCOUNT = 10;    private ExecutorService executorService;    private CountDownLatch latch = new CountDownLatch(TCOUNT);    private long completeLength = 0;    private long fileLength;    private static UpdateData mUpdateData;    private static DownLoadFileManager mDownLoadFileManager;    private static OnDownloadProgressListener mOnDownloadProgressListener;    public static DownLoadFileManager getInstance (UpdateData info,OnDownloadProgressListener listener) {        mUpdateData = info;        mOnDownloadProgressListener = listener;        if (mDownLoadFileManager == null) {            mDownLoadFileManager = new DownLoadFileManager();        }        return mDownLoadFileManager;    }    public void download() {        ExecutorService executorService = Executors.newFixedThreadPool(TCOUNT);        URL url = null;        try {            url = new URL(mUpdateData.getUrl());            URLConnection urlConnection = url.openConnection();            fileLength = urlConnection.getContentLength();            long packageLength = fileLength / TCOUNT;            long leftLength = fileLength % TCOUNT;            RandomAccessFile file = new RandomAccessFile("/sdcard/" + mUpdateData.getAppName() + ".apk","rw");            //计算每个线程请求文件的开始和结束位置            long pos = 0;            long endPos = pos + packageLength;            for(int i=0; i< TCOUNT; i++){                if(leftLength > 0){                    endPos ++;                    leftLength--;                }                executorService.execute(new DownLoadThread(url, file, pos, endPos));                pos = endPos;                endPos = pos + packageLength;            }            latch.await();            file.close();            executorService.shutdown();        } catch (MalformedURLException e) {            e.printStackTrace();        } catch (InterruptedException e) {            e.printStackTrace();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }    }    class DownLoadThread extends Thread{        private URL url;        private RandomAccessFile file;        private long from;        private long end;        public DownLoadThread(URL url, RandomAccessFile file, long from, long end){            this.url = url;            this.file = file;            this.from = from;            this.end = end;        }        public void run() {            long pos = from;            byte[] buff = new byte[1024];            try {                HttpURLConnection cn = (HttpURLConnection) url.openConnection();                cn.setRequestProperty("Range", "bytes=" + from + "-" + end);                if(cn.getResponseCode() != 200 && cn.getResponseCode()!=206){                    run();                    return;                }                BufferedInputStream bis = new BufferedInputStream(cn.getInputStream());                int length ;                while((length = bis.read(buff)) != -1){                    synchronized(file){                        file.seek(pos);                        file.write(buff, 0, length);                    }                    pos += length;                    completeLength += length;//                    Log.e(TAG,"--------------------------" + completeLength * 100 / fileLength + "%" + "--------------------------");                    if (mOnDownloadProgressListener != null) {                        mUpdateData.setProgress((int) (completeLength * 100 / fileLength));                        mOnDownloadProgressListener.onDownloadProgress(mUpdateData);                    }                }                cn.disconnect();                latch.countDown();            } catch (IOException e) {                e.printStackTrace();            }        }    }}